/**
 * State Migration and Schema Versioning
 * Protects user data during architectural refactoring
 * 
 * CRITICAL: This module ensures zero data loss during the transition
 * from 28-useState implementation to single useReducer architecture
 */

import { TimelineState, Task, TimelineTask } from '../types/timeline.types';

// Schema version tracking
export const CURRENT_SCHEMA_VERSION = 2;

// ============================================
// Migration Types and Constants
// ============================================

type MigrationVersion = 'initial' | 'v1.0' | 'v2.0';

const MIGRATION_VERSIONS = {
  INITIAL: 'initial' as MigrationVersion,
  V1: 'v1.0' as MigrationVersion,
  CURRENT: 'v2.0' as MigrationVersion,
};

// Helper functions
function needsMigration(state: any): boolean {
  return !state._migrationVersion || state._migrationVersion !== MIGRATION_VERSIONS.CURRENT;
}

function validateStateShape(data: any): any {
  // Basic validation - ensure state has required structure
  return data;
}

function migrateV1ToV2(data: any): MigrationResult {
  return {
    success: true,
    migratedData: data,
    migrationApplied: ['V1 to V2 migration']
  };
}

// Version 1: Original 28-useState structure (current implementation)
// Version 2: New useReducer structure (target architecture)

export interface VersionedState {
  version: number;
  timestamp: string;
  data: any; // Can be V1 or V2 structure
}

export interface MigrationResult {
  success: boolean;
  migratedData?: TimelineState;
  error?: string;
  warnings?: string[];
  migrationApplied?: string[];
}

/**
 * Migrate state from any previous version to current schema
 * This function MUST handle the transition gracefully
 */
export const migrateState = (storedState: VersionedState): MigrationResult => {
  try {
    console.log(`[StateMigration] Starting migration from version ${storedState.version} to ${CURRENT_SCHEMA_VERSION}`);
    
    if (!storedState.version) {
      // Handle legacy state without version (pre-refactoring)
      return migrateLegacyState(storedState.data);
    }

    if (storedState.version === CURRENT_SCHEMA_VERSION) {
      // No migration needed
      return {
        success: true,
        migratedData: validateStateShape(storedState.data),
        migrationApplied: []
      };
    }

    if (storedState.version === 1) {
      // Migrate from V1 (28-useState) to V2 (useReducer)
      return migrateV1ToV2(storedState.data);
    }

    // Future versions would be handled here
    return {
      success: false,
      error: `Unknown schema version: ${storedState.version}`
    };

  } catch (error) {
    console.error('[StateMigration] Migration failed:', error);
    return {
      success: false,
      error: `Migration failed: ${error instanceof Error ? error.message : String(error)}`
    };
  }
};

/**
 * Migrate legacy state (pre-versioning) to V2 structure
 * This handles the current localStorage format
 */
const migrateLegacyState = (legacyState: any): MigrationResult => {
  const warnings: string[] = [];
  const migrationApplied: string[] = [];

  try {
    // Current localStorage structure (from TimelineBuilder.js getCurrentFlatState)
    const migratedData: TimelineState = {
      assets: {
        available: legacyState.availableAssetTypes || [],
        selected: legacyState.selectedAssets || [],
        liveDates: legacyState.assetLiveDates || {},
        taskDurations: legacyState.assetTaskDurations || {}
      },
      tasks: {
        all: [], // Will be populated from CSV data
        bank: {}, // Legacy taskBank structure - needs conversion
        byAsset: {}, // Will be computed during hydration
        timeline: [], // Will be recalculated after hydration
        custom: legacyState.customTasks || [],
        names: legacyState.customTaskNames || {}
      },
      dates: {
        globalLiveDate: legacyState.globalLiveDate || '',
        useGlobalDate: legacyState.useGlobalDate ?? true,
        projectStartDate: '', // Will be recalculated
        bankHolidays: legacyState.bankHolidays || []
      },
      ui: {
        showInfoBox: legacyState.showInfoBox ?? true,
        showGettingStarted: false, // Reset UI state on migration
        showAllInstructions: false,
        dateErrors: [] // Will be recalculated
      },
      status: 'ready'
    };

    migrationApplied.push('Legacy state structure converted to V2');

    // Validate critical data preservation
    if (legacyState.selectedAssets?.length > 0) {
      migrationApplied.push(`Preserved ${legacyState.selectedAssets.length} selected assets`);
    }

    if (legacyState.customTasks?.length > 0) {
      migrationApplied.push(`Preserved ${legacyState.customTasks.length} custom tasks`);
    }

    // Check for data that needs special handling
    if (legacyState.taskDependencies && Object.keys(legacyState.taskDependencies).length > 0) {
      warnings.push('Task dependencies found but not migrated - will need recalculation');
      migrationApplied.push('Task dependencies preserved in legacy format');
    }

    if (legacyState.calculatedStartDates) {
      warnings.push('Calculated start dates will be recalculated after migration');
    }

    return {
      success: true,
      migratedData,
      warnings,
      migrationApplied
    };

  } catch (error) {
    return {
      success: false,
      error: `Legacy migration failed: ${error instanceof Error ? error.message : String(error)}`
    };
  }
};

/**
 * Migrate from V1 (first versioned state) to V2 (current)
 * This will be used for any intermediate versions
 */
const migrateV1ToV2 = (v1State: any): MigrationResult => {
  const migrationApplied: string[] = [];
  
  try {
    // V1 to V2 migration would go here
    // For now, assume V1 is already in the correct structure
    const migratedData = validateStateShape(v1State);
    
    migrationApplied.push('V1 to V2 migration completed');
    
    return {
      success: true,
      migratedData,
      migrationApplied
    };

  } catch (error) {
    return {
      success: false,
      error: `V1 to V2 migration failed: ${error instanceof Error ? error.message : String(error)}`
    };
  }
};

/**
 * Validate that migrated state matches expected TimelineState shape
 */
const validateStateShape = (state: any): TimelineState => {
  // Ensure all required properties exist with correct types
  const validatedState: TimelineState = {
    assets: {
      available: Array.isArray(state.assets?.available) ? state.assets.available : [],
      selected: Array.isArray(state.assets?.selected) ? state.assets.selected : [],
      liveDates: typeof state.assets?.liveDates === 'object' ? state.assets.liveDates : {},
      taskDurations: typeof state.assets?.taskDurations === 'object' ? state.assets.taskDurations : {}
    },
    tasks: {
      all: Array.isArray(state.tasks?.all) ? state.tasks.all : [],
      bank: typeof state.tasks?.bank === 'object' ? state.tasks.bank : {},
      byAsset: typeof state.tasks?.byAsset === 'object' ? state.tasks.byAsset : {},
      timeline: Array.isArray(state.tasks?.timeline) ? state.tasks.timeline : [],
      custom: Array.isArray(state.tasks?.custom) ? state.tasks.custom : [],
      names: typeof state.tasks?.names === 'object' ? state.tasks.names : {}
    },
    dates: {
      globalLiveDate: typeof state.dates?.globalLiveDate === 'string' ? state.dates.globalLiveDate : '',
      useGlobalDate: typeof state.dates?.useGlobalDate === 'boolean' ? state.dates.useGlobalDate : true,
      projectStartDate: typeof state.dates?.projectStartDate === 'string' ? state.dates.projectStartDate : '',
      bankHolidays: Array.isArray(state.dates?.bankHolidays) ? state.dates.bankHolidays : []
    },
    ui: {
      showInfoBox: typeof state.ui?.showInfoBox === 'boolean' ? state.ui.showInfoBox : true,
      showGettingStarted: typeof state.ui?.showGettingStarted === 'boolean' ? state.ui.showGettingStarted : false,
      showAllInstructions: typeof state.ui?.showAllInstructions === 'boolean' ? state.ui.showAllInstructions : false,
      dateErrors: Array.isArray(state.ui?.dateErrors) ? state.ui.dateErrors : []
    },
    status: state.status || 'ready'
  };

  return validatedState;
};

/**
 * Save state with current schema version
 */
export const saveVersionedState = (state: TimelineState): void => {
  const versionedState: VersionedState = {
    version: CURRENT_SCHEMA_VERSION,
    timestamp: new Date().toISOString(),
    data: state
  };

  try {
    localStorage.setItem('timeline-state', JSON.stringify(versionedState));
    console.log(`[StateMigration] State saved with version ${CURRENT_SCHEMA_VERSION}`);
  } catch (error) {
    console.error('[StateMigration] Failed to save state:', error);
  }
};

/**
 * Load and migrate state from localStorage
 */
export const loadVersionedState = (): MigrationResult => {
  try {
    const storedData = localStorage.getItem('timeline-state');
    
    if (!storedData) {
      return {
        success: true,
        migratedData: createInitialState(),
        migrationApplied: ['Created initial empty state']
      };
    }

    const parsedData = JSON.parse(storedData);
    
    // Handle both versioned and legacy (unversioned) states
    if (parsedData.version) {
      // Already versioned
      return migrateState(parsedData);
    } else {
      // Legacy state - treat as data directly
      return migrateLegacyState(parsedData);
    }

  } catch (error) {
    console.error('[StateMigration] Failed to load state:', error);
    return {
      success: false,
      error: `Failed to load state: ${error instanceof Error ? error.message : String(error)}`
    };
  }
};

/**
 * Create clean initial state for new users
 */
export const createInitialState = (): TimelineState => ({
  assets: {
    available: [],
    selected: [],
    liveDates: {},
    taskDurations: {}
  },
  tasks: {
    all: [],
    bank: {},
    byAsset: {},
    timeline: [],
    custom: [],
    names: {}
  },
  dates: {
    globalLiveDate: '',
    useGlobalDate: true,
    projectStartDate: '',
    bankHolidays: []
  },
  ui: {
    showInfoBox: true,
    showGettingStarted: false,
    showAllInstructions: false,
    dateErrors: []
  },
  status: 'ready'
});

/**
 * Backup current state before major operations
 */
export const createStateBackup = (label: string): boolean => {
  try {
    const currentState = localStorage.getItem('timeline-state');
    if (currentState) {
      const backupKey = `timeline-state-backup-${label}-${Date.now()}`;
      localStorage.setItem(backupKey, currentState);
      console.log(`[StateMigration] Backup created: ${backupKey}`);
      return true;
    }
    return false;
  } catch (error) {
    console.error('[StateMigration] Failed to create backup:', error);
    return false;
  }
};

/**
 * Restore from backup (for rollback scenarios)
 */
export const restoreFromBackup = (backupKey: string): boolean => {
  try {
    const backupData = localStorage.getItem(backupKey);
    if (backupData) {
      localStorage.setItem('timeline-state', backupData);
      console.log(`[StateMigration] Restored from backup: ${backupKey}`);
      return true;
    }
    return false;
  } catch (error) {
    console.error('[StateMigration] Failed to restore from backup:', error);
    return false;
  }
};

/**
 * List available backups for recovery
 */
export const listBackups = (): string[] => {
  const backups: string[] = [];
  
  try {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('timeline-state-backup-')) {
        backups.push(key);
      }
    }
  } catch (error) {
    console.error('[StateMigration] Failed to list backups:', error);
  }
  
  return backups.sort().reverse(); // Most recent first
};

/**
 * Clean up old backups to prevent localStorage bloat
 */
export const cleanupOldBackups = (keepCount: number = 5): number => {
  const backups = listBackups();
  const toDelete = backups.slice(keepCount);
  
  let deletedCount = 0;
  for (const backup of toDelete) {
    try {
      localStorage.removeItem(backup);
      deletedCount++;
    } catch (error) {
      console.error(`[StateMigration] Failed to delete backup ${backup}:`, error);
    }
  }
  
  if (deletedCount > 0) {
    console.log(`[StateMigration] Cleaned up ${deletedCount} old backups`);
  }
  
  return deletedCount;
}

/**
 * Get the current version of a timeline state
 */
export function getStateVersion(state: any): MigrationVersion {
  if ((state as any)._migrationVersion) {
    return state._migrationVersion;
  }
  
  // Legacy state - no version field
  return MIGRATION_VERSIONS.INITIAL;
}

// ============================================
// Task Migration Functions
// ============================================

/**
 * Add empty dependency arrays to tasks that don't have them
 * Following Golden Rule #1: Safety First - Preserve all existing data
 */
function migrateTasks(tasks: Task[]): Task[] {
  return tasks.map(task => {
    // If task already has dependencies property, leave it unchanged
    if (task.hasOwnProperty('dependencies')) {
      return task;
    }

    // Add empty dependencies array for DAG calculator compatibility
    return {
      ...task,
      dependencies: undefined // Optional property - undefined means no dependencies
    };
  });
}

/**
 * Migrate task bank (nested task collections)
 */
function migrateTaskBank(taskBank: Record<string, Task[]>): Record<string, Task[]> {
  const migratedBank: Record<string, Task[]> = {};

  for (const [assetId, tasks] of Object.entries(taskBank)) {
    migratedBank[assetId] = migrateTasks(tasks);
  }

  return migratedBank;
}

/**
 * Migrate timeline tasks (preserve DAG-specific properties if they exist)
 */
function migrateTimelineTasks(timelineTasks: TimelineTask[]): TimelineTask[] {
  return timelineTasks.map(task => {
    // Preserve existing DAG properties if they exist
    const migratedTask: TimelineTask = {
      ...task,
      // Ensure dependencies property exists (even if undefined)
      dependencies: task.dependencies || undefined
    };

    return migratedTask;
  });
}

// ============================================
// Main Migration Function
// ============================================

/**
 * Migrate timeline state to support DAG calculator
 * Following Golden Rule #1: Safety First - Comprehensive error handling
 * Following Golden Rule #6: PM-Friendly - Never lose user work
 */
export function migrateTimelineState(state: any): TimelineState {
  try {
    // If no migration needed, return as-is (with version added)
    if (!needsMigration(state)) {
      return {
        ...state,
        _migrationVersion: MIGRATION_VERSIONS.CURRENT
      } as any;
    }

    const currentVersion = getStateVersion(state);
    
    console.log(`Migrating timeline state from version ${currentVersion} to ${MIGRATION_VERSIONS.CURRENT}`);

    // Create migrated state with all existing data preserved
    const migratedState: TimelineState = {
      // Preserve all existing state structure
      assets: {
        available: state.assets?.available || [],
        selected: state.assets?.selected || [],
        liveDates: state.assets?.liveDates || {},
        taskDurations: state.assets?.taskDurations || {}
      },

      tasks: {
        // Migrate all task collections to support dependencies
        all: migrateTasks(state.tasks?.all || []),
        bank: migrateTaskBank(state.tasks?.bank || {}),
        byAsset: state.tasks?.byAsset ? 
          Object.fromEntries(
            Object.entries(state.tasks.byAsset).map(([key, tasks]) => [
              key, 
              migrateTasks(tasks as Task[])
            ])
          ) : {},
        timeline: migrateTimelineTasks(state.tasks?.timeline || []),
        custom: migrateTasks(state.tasks?.custom || []),
        names: state.tasks?.names || {}
      },

      dates: {
        globalLiveDate: state.dates?.globalLiveDate || '',
        useGlobalDate: state.dates?.useGlobalDate ?? true,
        projectStartDate: state.dates?.projectStartDate || '',
        bankHolidays: state.dates?.bankHolidays || [],
        // Preserve any calculated dates
        calculatedStartDates: state.dates?.calculatedStartDates || undefined
      },

      ui: {
        showInfoBox: state.ui?.showInfoBox ?? true,
        showGettingStarted: state.ui?.showGettingStarted ?? false,
        showAllInstructions: state.ui?.showAllInstructions ?? false,
        dateErrors: state.ui?.dateErrors || []
      },

      // Add migration version for future migrations
      _migrationVersion: MIGRATION_VERSIONS.CURRENT
    } as any;

    console.log(`Successfully migrated timeline state. Tasks migrated: ${
      migratedState.tasks.all.length + migratedState.tasks.custom.length
    }`);

    return migratedState;

  } catch (error) {
    console.error('Timeline state migration failed:', error);
    
    // Following Golden Rule #1: Safety First - If migration fails, 
    // return a safe default state rather than crash
    const fallbackState: TimelineState = {
      assets: {
        available: [],
        selected: [],
        liveDates: {},
        taskDurations: {}
      },
      tasks: {
        all: [],
        bank: {},
        byAsset: {},
        timeline: [],
        custom: [],
        names: {}
      },
      dates: {
        globalLiveDate: '',
        useGlobalDate: true,
        projectStartDate: '',
        bankHolidays: []
      },
      ui: {
        showInfoBox: true,
        showGettingStarted: false,
        showAllInstructions: false,
        dateErrors: []
      },
      _migrationVersion: MIGRATION_VERSIONS.CURRENT
    } as any;

    console.warn('Using fallback state due to migration failure');
    return fallbackState;
  }
}

// ============================================
// Migration Validation
// ============================================

/**
 * Validate that a migrated state is properly formed
 * Following Golden Rule #1: Safety First - Verify migration success
 */
export function validateMigratedState(state: TimelineState): {
  valid: boolean;
  errors: string[];
  warnings: string[];
} {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Check required top-level properties
  if (!state.assets) errors.push('Missing assets state');
  if (!state.tasks) errors.push('Missing tasks state');
  if (!state.dates) errors.push('Missing dates state');
  if (!state.ui) errors.push('Missing UI state');

  // Check migration version
  if (!(state as any)._migrationVersion) {
    warnings.push('Migration version not set');
  }

  // Validate task structure (all tasks should be compatible with DAG calculator)
  const allTasks = [
    ...(state.tasks?.all || []),
    ...(state.tasks?.custom || []),
    ...(state.tasks?.timeline || [])
  ];

  allTasks.forEach((task, index) => {
    if (!task.id) {
      errors.push(`Task at index ${index} missing required id`);
    }
    
    if (!task.name) {
      errors.push(`Task ${task.id || index} missing required name`);
    }

    // Dependencies property should exist (even if undefined for sequential tasks)
    if (!task.hasOwnProperty('dependencies')) {
      warnings.push(`Task ${task.id || index} missing dependencies property (added during migration)`);
    }
  });

  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}

// ============================================
// Storage Migration Helpers
// ============================================

/**
 * Migrate state from localStorage if needed
 * Following Golden Rule #6: PM-Friendly - Preserve saved work
 */
export function migrateLocalStorageState(): TimelineState | null {
  try {
    const saved = localStorage.getItem('timeline_state');
    if (!saved) return null;

    const parsedState = JSON.parse(saved);
    
    if (needsMigration(parsedState)) {
      console.log('Migrating saved timeline state from localStorage');
      const migratedState = migrateTimelineState(parsedState);
      
      // Validation check
      const validation = validateMigratedState(migratedState);
      if (!validation.valid) {
        console.error('Migration validation failed:', validation.errors);
        return null;
      }

      // Save migrated state back to localStorage
      localStorage.setItem('timeline_state', JSON.stringify(migratedState));
      
      if (validation.warnings.length > 0) {
        console.warn('Migration completed with warnings:', validation.warnings);
      }

      return migratedState;
    }

    return parsedState;
  } catch (error) {
    console.error('Failed to migrate localStorage state:', error);
    return null;
  }
}

// ============================================
// Migration Report
// ============================================

export interface MigrationReport {
  migrated: boolean;
  fromVersion: MigrationVersion;
  toVersion: MigrationVersion;
  tasksProcessed: number;
  assetsPreserved: number;
  warnings: string[];
  timestamp: string;
}

/**
 * Generate a migration report for logging/debugging
 */
export function generateMigrationReport(
  originalState: any,
  migratedState: TimelineState
): MigrationReport {
  return {
    migrated: needsMigration(originalState),
    fromVersion: getStateVersion(originalState),
    toVersion: MIGRATION_VERSIONS.CURRENT,
    tasksProcessed: (migratedState.tasks?.all?.length || 0) + (migratedState.tasks?.custom?.length || 0),
    assetsPreserved: migratedState.assets?.selected?.length || 0,
    warnings: validateMigratedState(migratedState).warnings,
    timestamp: new Date().toISOString()
  };
}